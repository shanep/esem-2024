#+title: SLR CTTC
#+bibliography: slr-paper-memory-safety-rust.bib
#+tags: rustlang osimpl


* Tighten rust's belt: shrinking embedded Rust                          :RQ3:

- [cite:@Ayers2022-vk]

This paper focused on the size of rust binaries in the embedded environment. Their work primary
focused on the size of binaries produced using the embedded OS Tock. The authors identified four
major causes of binary growth:
- Deeply ingrained monomorphization
- Suboptimal compiler generated support code
- Hidden data structures and data
- Fewer compiler optimizations

In addition to the identified causes of binary growth the authors have the following 5
recommendations when using Rust in a size constrained environment:
- Minimize Length + Instantiations of Generic Code
- Use Trait Objects Sparingly
- Don't Panic
- Carefully Use Compiler Generated Support Code
- Don't use static mut

One point that the Authors did not address is how these changes impacted code maintainability and
readability. As with any optimization technique the final binary may have been smaller at a cost of
difficult to follow code.

1. Can the 5 techniques that the authors identified be applied to the C->rust translators?
2. Have these techniques been integrated into the Linux Kernel?
3. Can we add the 5 techniques to the clippy static checker?
4. Can we take the embedded_data_analyzer and use it in Linux?

* Theseus: an Experiment in Operating System  Structure and State Management :RQ1:

- [cite:@Boos2020-zh]

This paper is about an experimental operating system that is aimed at addressing the state spill
problem. State spill happens when a single service in an operating system can harbor a state change,
induced by interacting with other services, that can eventually cause a system crash or system
instability. The operating system is built in Rust and leverages the properties of Rust to construct
a safer system.

The OS operates in a single address space and single privilege level and uses properties of the Rust
programming language to realize isolation instead of relying on hardware. The design of the OS uses
a novel cell based structure where ownership of memory and resources is enforced by the compiler. In
short the Theseus OS is an operating system that was designed to match the Rust language instead of
the more traditional route of matching the hardware.

Because Theseus does not implement a POSIX interface it is unclear as to how you would execute
existing software on this OS. While this OS is very unique I believe it is critical to somehow
support the billions of lines of existing code all ready out

1. How would you isolate a POSIX C based program?
2. Does operating in a single privilege layer improve performance?

* Isolation in Rust: What is Missing?                                   :RQ3:

- [cite:@Burtsev2021-rq]

This paper explores what is missing in the Rust programming language to help solve the isolation
problem. Currently Rust lacks the ability to express isolation in the heap without external
support. The RedLeaf experiential operating system realize on an complex interface definition
language (IDL) to enforce isolated heaps. The paper enumerates several properties of the Rust
Language that could help with Isolation. 1) Supporting trait bounds on functions and closures with
any number of arguments 2) Expose type information in procedural macros 3) Support a collision-free,
unique type identifier 4) Support extendable, no_std unwind library 5) Support typed assembly
language for Rust 6) Support trusted build environments 7) Provide software-only stack guard with
extensible probing interface 8) Develop zero-copy serialization of “plain- old” data structures.

This paper outlines some of the features that rust would need however, as the authors noted some of
the requested features such as supporting trait bounds on functions were closed due to lack of
interest from the community.

1. How can thread unwinding be better supporting in no_std environments?

* Atmosphere: Towards Practical Verified Kernels in Rust            :RQ1:RQ4:

The authors primary focused on developing a micro-kernel in Rust that could be formally verified
by using both the liner type system or rust and a SMT solver. The new micro-kernel named Atmosphere
pushes most kernel functionally to users-space thus limiting the surface area that needs to be
proved. The authors were able to get a 7.5:1 proof-to-code ratio which is higher that other formerly
verified microkernels SeL4 and CeriKOS, which both have proof-tocode ratio of 19:1 and 20:1
respectively.

* A Low-Latency Optimization of a Rust-Based Secure Operating System for Embedded Devices :RQ2:

- [cite:@Culic2022-bk]

This paper addressed latency issues in a new OS written in Rust. Tock is a new operating system that
is designed to run on embedded systems but does not provide Real time capabilities. The authors
attempted to add real time capabilities by integrating eBPF into the Tock kernel to improve the
interrupt handlers response time. The Authors found that early work (still in the prototype stage)
lowers the response times of the system and makes interrupt response times 3x

* Takeaways of Implementing a Native Rust UDP Tunneling Network Driver in the Linux Kernel :RQ2:

This paper explored using the Rust for Linux Project to implement a native UDP driver in Rust. The
authors were able to get a basic driver working with performance only slightly slower than C. The
RFL project is still to immature to get a full driver up and running. There are several missing
networking abstractions that do not exist in the project to do a full production grade driver.

* Leveraging Rust for Lightweight OS Correctness                        :RQ4:

This paper explores advances and details and lessons learned in implementing Theseus, an operating
system written in Rust. The authors describe how Theseus uses intralingual design to maximize the
compilers role in enforcing correctness. By leveraging Rusts type system and borrow checker memory
safety and correct ownership transfer can be achieved at a higher level than what could be done in
C. The authors also detailed some of the limitations of intralingual design such as not being as
expressive as many other formal verification techniques due to the limited invariant that can be
enforced by the type system. One of the most important lessons learned was the incite that a linear
type system itself cannot guarantee uniqueness of the resource represented, such when a memory
resources may overlap. The authors introduce the idea of using a hybrid approach of verification
where they leverage both the linear type system and an SMT solver.

* On the Challenge of Sound Code for Operating Systems                  :RQ3:



* References

#+print_bibliography:
